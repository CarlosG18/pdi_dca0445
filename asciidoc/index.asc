:numbered:
:author: CARLOS GABRIEL MEDEIROS DA SILVA
:icons:
:experimental:
:stem:
:imagesdir: ./figs
:toc: left
:doctype: book
:source-highlighter: pygments
:caution-caption: Cuidado
:important-caption: Importante
:note-caption: Nota
:tip-caption: Dica
:warning-caption: Aviso
:appendix-caption: Apêndice
:example-caption: Exemplo
:figure-caption: Figura
:listing-caption: Listagem
:table-caption: Tabela
:toc-title: Sumário
:preface-title: Prefácio
:version-label: Versão
:last-update-label: Última atualização

= DCA0445: Processamento Digital de Imagens =

Carlos Gabriel <c.gabriel.abc18@gmail.com>

== Atividades Unidade 1

=== Prática 1 - Manipulando pixels em uma imagem (regions.cpp)

Foi desenvolvido um programa chamado "regions.cpp" com base no código "pixels.cpp" disponibilizado https://agostinhobritojr.github.io/tutorial/pdi/pixels.html[aqui]. Esse novo programa solicita ao usuário que informe as coordenadas de dois pontos, P1 e P2, dentro dos limites da imagem fornecida. A região delimitada pelo retângulo de vértices opostos nesses pontos é exibida com o efeito negativo aplicado, destacando essa área específica da imagem. 

O código utilizado para realizar essa prática esta descrito logo abaixo:

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

struct Point {
    int x;
    int y;

    Point(int value_x, int value_y) : x(value_x), y(value_y) {}
};

int main(int argc, char** argv) {
    cv::Mat image;

    if (argc != 5) {
        std::cout << "Uso: ./regions <P1_x> <P1_y> <P2_x> <P2_y>" << std::endl;
        return -1;
    }

    // Lendo os argumentos da linha de comando
    int P1_x = std::stoi(argv[1]);
    int P1_y = std::stoi(argv[2]);
    int P2_x = std::stoi(argv[3]);
    int P2_y = std::stoi(argv[4]);

    //verificação da região
    if (P1_x >= P2_x || P1_y >= P2_y){
        std::cout << "A região informada não está coerente!" << std::endl;
        return -1;
    }

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);
    if (!image.data) std::cout << "nao abriu bolhas.png" << std::endl;

    cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);
    
    // Criando os pontos
    Point point1(P1_x, P1_y);
    Point point2(P2_x, P2_y);

    for (int i = point1.x; i < point2.x; i++) {
        for (int j = point1.y; j < point2.y; j++) {
            // Certificando-se de que os índices estão dentro dos limites da imagem
            if (j >= 0 && j < image.rows && i >= 0 && i < image.cols) {
                image.at<uchar>(i, j) = 255 - image.at<uchar>(i, j);
            }
        }
    }
    cv::imshow("janela", image);
    cv::waitKey();
    return 0;
}
----

==== Comentários sobre o código

* Foi criado uma **__struct__** basica para representar os pontos;

* Com os pontos coletados, foi feito uma varedura entre os pixels da area informada e atribuido o negativo a partir da operação **__image.at<uchar>(i, j) = 255 - image.at<uchar>(i, j);__**;

A Figura 1 ilustra o resultado obtido:

[#image-result1]
.resultado_pratica1.png
image::resultado_pratica1.png[Resultado da Prática 1]

---

=== Prática 2
[source,cpp]
----
#include <iostream>
using namespace std;

int main() {
    cout << "Exemplo de código para a Prática 2" << endl;
    return 0;
}
----

imagem::pratica2_resposta.png[Resposta da Prática 2]

=== Prática 3
[source,cpp]
----
#include <iostream>
using namespace std;

int main() {
    cout << "Exemplo de código para a Prática 3" << endl;
    return 0;
}
----

imagem::pratica3_resposta.png[Resposta da Prática 3]

=== Prática 4
[source,cpp]
----
#include <iostream>
using namespace std;

int main() {
    cout << "Exemplo de código para a Prática 4" << endl;
    return 0;
}
----

imagem::pratica4_resposta.png[Resposta da Prática 4]


== unidade 2 ==

== unidade 3 ==

== Bibliografia ==
[bibliography]
- Stephen Prata. 'C++ Primer Plus'. Addison-Wesley. 1990. 2 ed.
- http://www.cplusplus.com. 'Principal portal de desenvolvimento e referência para programação em C++'.


