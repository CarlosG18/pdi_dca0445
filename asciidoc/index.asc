:numbered:
:author: CARLOS GABRIEL MEDEIROS DA SILVA
:icons:
:experimental:
:stem:
:imagesdir: ./figs
:toc: left
:doctype: book
:source-highlighter: pygments
:caution-caption: Cuidado
:important-caption: Importante
:note-caption: Nota
:tip-caption: Dica
:warning-caption: Aviso
:appendix-caption: Apêndice
:example-caption: Exemplo
:figure-caption: Figura
:listing-caption: Listagem
:table-caption: Tabela
:toc-title: Sumário
:preface-title: Prefácio
:version-label: Versão
:last-update-label: Última atualização

= DCA0445: Processamento Digital de Imagens =

Carlos Gabriel <c.gabriel.abc18@gmail.com>

== Atividades Unidade 1

=== Prática 1 - Manipulando pixels em uma imagem (regions.cpp)

Foi desenvolvido um programa chamado "regions.cpp" com base no código "pixels.cpp" disponibilizado https://agostinhobritojr.github.io/tutorial/pdi/pixels.html[aqui]. Esse novo programa solicita ao usuário que informe as coordenadas de dois pontos, P1 e P2, dentro dos limites da imagem fornecida. A região delimitada pelo retângulo de vértices opostos nesses pontos é exibida com o efeito negativo aplicado, destacando essa área específica da imagem. 

O código utilizado para realizar essa prática esta descrito logo abaixo:

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

struct Point {
    int x;
    int y;

    Point(int value_x, int value_y) : x(value_x), y(value_y) {}
};

int main(int argc, char** argv) {
    cv::Mat image;

    if (argc != 5) {
        std::cout << "Uso: ./regions <P1_x> <P1_y> <P2_x> <P2_y>" << std::endl;
        return -1;
    }

    // Lendo os argumentos da linha de comando
    int P1_x = std::stoi(argv[1]);
    int P1_y = std::stoi(argv[2]);
    int P2_x = std::stoi(argv[3]);
    int P2_y = std::stoi(argv[4]);

    //verificação da região
    if (P1_x >= P2_x || P1_y >= P2_y){
        std::cout << "A região informada não está coerente!" << std::endl;
        return -1;
    }

    image = cv::imread("biel.png", cv::IMREAD_GRAYSCALE);
    if (!image.data) std::cout << "nao abriu bolhas.png" << std::endl;

    cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);
    
    // Criando os pontos
    Point point1(P1_x, P1_y);
    Point point2(P2_x, P2_y);

    for (int i = point1.x; i < point2.x; i++) {
        for (int j = point1.y; j < point2.y; j++) {
            // Certificando-se de que os índices estão dentro dos limites da imagem
            if (j >= 0 && j < image.rows && i >= 0 && i < image.cols) {
                image.at<uchar>(i, j) = 255 - image.at<uchar>(i, j);
            }
        }
    }
    cv::imshow("janela", image);
    cv::waitKey();
    return 0;
}
----

==== Comentários sobre o código

* Foi criado uma **__struct__** basica para representar os pontos;

* Com os pontos coletados, foi feito uma varedura entre os pixels da area informada e atribuido o negativo a partir da operação **__image.at<uchar>(i, j) = 255 - image.at<uchar>(i, j);__**;

A Figura 1 ilustra o resultado obtido:

[#image-result1]
.resultado_pratica1.png
image::resultado_pratica1.png[Resultado da Prática 1]

---

=== Prática 2 - Manipulando pixels em uma imagem (trocaregioes.cpp)

Foi desenvolvido um programa chamado "trocaregioes.cpp" com base no código "pixels.cpp" disponibilizado https://agostinhobritojr.github.io/tutorial/pdi/pixels.html[aqui]. Esse novo programa realiza uma transformação na imagem fornecida, trocando os quadrantes dispostos em diagonal. O usuário fornece uma imagem, e o programa divide-a em quatro quadrantes iguais. Em seguida, os quadrantes localizados em posições diagonais são trocados entre si, gerando uma nova composição visual onde a parte superior esquerda se alterna com a inferior direita e a parte superior direita com a inferior esquerda. Essa modificação altera a disposição da imagem, destacando novos detalhes na estrutura visual.

O código utilizado para realizar essa prática esta descrito logo abaixo:

[source,cpp]
----
#include <iostream>
#include <opencv2/opencv.hpp>

int main(int argc, char** argv) {
    cv::Mat image;
    cv::Rect rect(20, 50, 30, 30);

    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);
    if (!image.data) std::cout << "nao abriu!" << std::endl;

    // obtendo os quadrantes
    cv::Mat q1 = image(cv::Rect(0,0,image.cols/2,image.rows/2));
    cv::Mat q2 = image(cv::Rect(image.cols/2,0,image.cols/2,image.rows/2));
    cv::Mat q3 = image(cv::Rect(0,image.rows/2,image.cols/2,image.rows/2));
    cv::Mat q4 = image(cv::Rect(image.rows/2,image.cols/2,image.cols/2,image.rows/2));

    cv::Mat RowUp, RowDown, FinalImage;

    cv::hconcat(q4, q3, RowUp); // concatena horizontalmente duas matrizes (images)
    cv::hconcat(q2, q1, RowDown); // concatena horizontalmente duas matrizes (images)
    cv::vconcat(RowUp, RowDown, FinalImage); // concatena verticalmente duas matrizes (images)
    
    cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

    cv::imshow("janela", FinalImage);
    cv::waitKey();
    return 0;
}
----

==== Comentários sobre o código

* A imagem foi separada em 4 sub-imagens definindo as imagens de cada quadrante;

* Em seguida foi feito a concatenação das duas imagens do quadrante na horientação horizontal do **q4->q3** e do **q2->q1**;

* Por fim é feito a concatenação vertical das duas linhas concatenadas gerando a imagem com os quadrantes diagonais trocados.

A Figura 2 ilustra o resultado obtido:

[#image-result2]
.resultado_pratica2.png
image::resultado_pratica2.png[Resultado da Prática 2]

=== Prática 3 - Filtragem no domínio espacial I - Convolução

==== Exercicio 1 - (convolucao2.cpp)

O programa deverá realizar a convolução com o filtro da média para máscaras de tamanho 11×11 e 21×21 pixels. Compare os resultados obtidos com o filtro de tamanho 3×3 pixels.

O código utilizado para realizar essa prática esta descrito logo abaixo:

[source,cpp]
----
...
float media[] = {0.1111, 0.1111, 0.1111, 0.1111, 0.1111,
                   0.1111, 0.1111, 0.1111, 0.1111};
float gauss[] = {0.0625, 0.125,  0.0625, 0.125, 0.25,
                0.125,  0.0625, 0.125,  0.0625};
float horizontal[] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
float vertical[] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
float laplacian[] = {0, -1, 0, -1, 4, -1, 0, -1, 0};
float boost[] = {0, -1, 0, -1, 5.2, -1, 0, -1, 0};
...
----

==== Comentários sobre o código

* Básicamente o que irá mudar no código sera apenas as mascaras de convolução.

A Figura 3 ilustra o resultado obtido:

[#image-result3]
.resultado_pratica3.png
image::resultado_pratica3.png[Resultado da Prática 3]

==== Exercicio 2 - (convolucao2.cpp)







=== Prática 4
[source,cpp]
----
#include <iostream>
using namespace std;

int main() {
    cout << "Exemplo de código para a Prática 4" << endl;
    return 0;
}
----

imagem::pratica4_resposta.png[Resposta da Prática 4]


== unidade 2 ==

== unidade 3 ==

== Bibliografia ==
[bibliography]
- Stephen Prata. 'C++ Primer Plus'. Addison-Wesley. 1990. 2 ed.
- http://www.cplusplus.com. 'Principal portal de desenvolvimento e referência para programação em C++'.


